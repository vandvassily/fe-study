# 链表

单链表，双向链表，循环链表

## 如何基于链表实现 LRU 缓存淘汰算法？

我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况
    如果此时缓存未满，则将此结点直接插入到链表的头部；
    如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

这样我们就用链表实现了一个 LRU 缓存，是不是很简单？

## 如何轻松写出正确的链表代码

### 1. 技巧一：理解指针或引用的含义

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

### 2. 技巧二：警惕指针丢失和内存泄漏

我们插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏

### 3. 技巧三：利用哨兵简化实现难度

针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。

### 4. 技巧四：重点留意边界条件处理

我经常用来检查链表代码是否正确的边界条件有这样几个：

    如果链表为空时，代码是否能正常工作？
    如果链表只包含一个结点时，代码是否能正常工作？
    如果链表只包含两个结点时，代码是否能正常工作？
    代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

### 5. 技巧五：举例画图，辅助思考

举例法和画图法。 