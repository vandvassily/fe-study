<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.27">
    <link rel="icon" href="/favicon.ico"><title>JS基础知识题目 | fe-study</title><meta name="description" content="前端知识笔记">
    <link rel="modulepreload" href="/fe-study/assets/app.9bc35547.js"><link rel="modulepreload" href="/fe-study/assets/js基础知识.html.fe8275d9.js"><link rel="modulepreload" href="/fe-study/assets/plugin-vue_export-helper.5a098b48.js"><link rel="modulepreload" href="/fe-study/assets/js基础知识.html.714d5d38.js">
    <link rel="stylesheet" href="/fe-study/assets/style.2c625487.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/fe-study/" class=""><!----><span class="site-name can-hide">fe-study</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/fe-study/" class="nav-link" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="http://vandvassily.cn/" rel="noopener noreferrer" target="_blank" aria-label="Blog"><!--[--><!--]--> Blog <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/vandvassily/fe-study" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/fe-study/" class="nav-link" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="http://vandvassily.cn/" rel="noopener noreferrer" target="_blank" aria-label="Blog"><!--[--><!--]--> Blog <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/vandvassily/fe-study" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><a href="/fe-study/javascript/" class="nav-link sidebar-heading sidebar-item" aria-label="JS知识"><!--[--><!--]--> JS知识 <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/fe-study/javascript/basic/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html" class="nav-link sidebar-item" aria-label="数据类型"><!--[--><!--]--> 数据类型 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/basic/%E5%8E%9F%E5%9E%8B.html" class="nav-link sidebar-item" aria-label="原型、原型链、继承"><!--[--><!--]--> 原型、原型链、继承 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/basic/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F.html" class="nav-link sidebar-item" aria-label="词法作用域"><!--[--><!--]--> 词法作用域 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/basic/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html" class="nav-link sidebar-item" aria-label="执行上下文"><!--[--><!--]--> 执行上下文 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/basic/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88.html" class="nav-link sidebar-item" aria-label="JavaScript深入之执行上下文栈"><!--[--><!--]--> JavaScript深入之执行上下文栈 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/basic/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html" class="nav-link sidebar-item" aria-label="作用域链"><!--[--><!--]--> 作用域链 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/basic/this.html" class="nav-link sidebar-item" aria-label="this"><!--[--><!--]--> this <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/basic/new.html" class="nav-link sidebar-item" aria-label="new 的原理"><!--[--><!--]--> new 的原理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/basic/call%20apply%20bind.html" class="nav-link sidebar-item" aria-label="call apply bind"><!--[--><!--]--> call apply bind <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/basic/EventLoop.html" class="nav-link sidebar-item" aria-label="EventLoop 事件循环"><!--[--><!--]--> EventLoop 事件循环 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/basic/array.html" class="nav-link sidebar-item" aria-label="数组方法"><!--[--><!--]--> 数组方法 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/basic/currying.html" class="nav-link sidebar-item" aria-label="函数柯里化"><!--[--><!--]--> 函数柯里化 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/basic/%E6%B7%B1%E6%8B%B7%E8%B4%9D.html" class="nav-link sidebar-item" aria-label="深拷贝"><!--[--><!--]--> 深拷贝 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/javascript/usage/debounce-throttle.html" class="nav-link sidebar-item" aria-label="防抖 与 节流"><!--[--><!--]--> 防抖 与 节流 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--[--><a href="/fe-study/browser/" class="nav-link sidebar-heading sidebar-item" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/fe-study/browser/%E8%BE%93%E5%85%A5URL.html" class="nav-link sidebar-item" aria-label="输入URL后，发生了什么"><!--[--><!--]--> 输入URL后，发生了什么 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--[--><a href="/fe-study/vue/" class="nav-link sidebar-heading sidebar-item" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/fe-study/vue/lifeCircle.html" class="nav-link sidebar-item" aria-label="Vue生命周期"><!--[--><!--]--> Vue生命周期 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/vue/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html" class="nav-link sidebar-item" aria-label="响应式原理"><!--[--><!--]--> 响应式原理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/vue/nextTick.html" class="nav-link sidebar-item" aria-label="异步更新队列"><!--[--><!--]--> 异步更新队列 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/vue/watcher.html" class="nav-link sidebar-item" aria-label="computed 和 watch 的原理"><!--[--><!--]--> computed 和 watch 的原理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/vue/diff.html" class="nav-link sidebar-item" aria-label="Diff算法"><!--[--><!--]--> Diff算法 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/vue/keep-alive.html" class="nav-link sidebar-item" aria-label="keep-alive 组件"><!--[--><!--]--> keep-alive 组件 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/vue/Vue3.html" class="nav-link sidebar-item" aria-label="Vue3"><!--[--><!--]--> Vue3 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--[--><a href="/fe-study/react/" class="nav-link sidebar-heading sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/fe-study/react/React%E6%9E%B6%E6%9E%84.html" class="nav-link sidebar-item" aria-label="React 架构"><!--[--><!--]--> React 架构 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/react/jsx.html" class="nav-link sidebar-item" aria-label="JSX是什么？"><!--[--><!--]--> JSX是什么？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/react/lifecircle.html" class="nav-link sidebar-item" aria-label="React的生命周期"><!--[--><!--]--> React的生命周期 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/react/React%20Hooks.html" class="nav-link sidebar-item" aria-label="React Hooks"><!--[--><!--]--> React Hooks <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/react/react%20performance.html" class="nav-link sidebar-item" aria-label="React 性能优化"><!--[--><!--]--> React 性能优化 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/react/setState.html" class="nav-link sidebar-item" aria-label="setState 知识点"><!--[--><!--]--> setState 知识点 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/react/React%20Events.html" class="nav-link sidebar-item" aria-label="React事件机制"><!--[--><!--]--> React事件机制 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/react/React%20%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0.html" class="nav-link sidebar-item" aria-label="React状态更新"><!--[--><!--]--> React状态更新 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/react/React%20Scheduler.html" class="nav-link sidebar-item" aria-label="React Scheduler 调度器和优先级"><!--[--><!--]--> React Scheduler 调度器和优先级 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/react/React%E9%9D%A2%E8%AF%95%E9%A2%98.html" class="nav-link sidebar-item" aria-label="React 面试题"><!--[--><!--]--> React 面试题 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/react/React%E6%BA%90%E7%A0%81.html" class="nav-link sidebar-item" aria-label="React源码"><!--[--><!--]--> React源码 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--[--><a href="/fe-study/typescript/" class="nav-link sidebar-heading sidebar-item" aria-label="Typescript"><!--[--><!--]--> Typescript <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/fe-study/typescript/typescript%E9%85%8D%E7%BD%AE.html" class="nav-link sidebar-item" aria-label="typescript配置详解"><!--[--><!--]--> typescript配置详解 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--[--><a href="/fe-study/network/" class="nav-link sidebar-heading sidebar-item" aria-label="网络"><!--[--><!--]--> 网络 <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/fe-study/network/tcp.html" class="nav-link sidebar-item" aria-label="TCP"><!--[--><!--]--> TCP <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/network/https.html" class="nav-link sidebar-item" aria-label="Https"><!--[--><!--]--> Https <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/network/security.html" class="nav-link sidebar-item" aria-label="web安全"><!--[--><!--]--> web安全 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--[--><a href="/fe-study/nodejs/" class="nav-link sidebar-heading sidebar-item" aria-label="NodeJs"><!--[--><!--]--> NodeJs <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/fe-study/nodejs/tools.html" class="nav-link sidebar-item" aria-label="Node 常用工具和指令"><!--[--><!--]--> Node 常用工具和指令 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--[--><a href="/fe-study/structure-and-algorithm/" class="nav-link sidebar-heading sidebar-item" aria-label="数据结构与算法"><!--[--><!--]--> 数据结构与算法 <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/fe-study/structure-and-algorithm/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A.html" class="nav-link sidebar-item" aria-label="时间复杂度"><!--[--><!--]--> 时间复杂度 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/structure-and-algorithm/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B.html" class="nav-link sidebar-item" aria-label="复杂度分析"><!--[--><!--]--> 复杂度分析 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/structure-and-algorithm/%E6%95%B0%E7%BB%84.html" class="nav-link sidebar-item" aria-label="数组"><!--[--><!--]--> 数组 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/structure-and-algorithm/%E9%93%BE%E8%A1%A8.html" class="nav-link sidebar-item" aria-label="链表"><!--[--><!--]--> 链表 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/structure-and-algorithm/%E6%8E%92%E5%BA%8F.html" class="nav-link sidebar-item" aria-label="排序"><!--[--><!--]--> 排序 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/structure-and-algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.html" class="nav-link sidebar-item" aria-label="二叉树的遍历"><!--[--><!--]--> 二叉树的遍历 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/structure-and-algorithm/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.html" class="nav-link sidebar-item" aria-label="回溯算法"><!--[--><!--]--> 回溯算法 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/structure-and-algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.html" class="nav-link sidebar-item" aria-label="字符串匹配"><!--[--><!--]--> 字符串匹配 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/structure-and-algorithm/dynamic-programming.html" class="nav-link sidebar-item" aria-label="动态规划"><!--[--><!--]--> 动态规划 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--[--><a href="/fe-study/performance/" class="nav-link sidebar-heading sidebar-item" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a><!----><!--]--><!--[--><a href="/fe-study/front-end-engineering/what-is-Frond-End-Engineering" class="nav-link sidebar-heading sidebar-item" aria-label="前端工程化"><!--[--><!--]--> 前端工程化 <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/fe-study/front-end-engineering/what-is-Frond-End-Engineering.html" class="nav-link sidebar-item" aria-label="什么是前端工程化？"><!--[--><!--]--> 什么是前端工程化？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/front-end-engineering/npm%20link.html" class="nav-link sidebar-item" aria-label="npm link"><!--[--><!--]--> npm link <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/front-end-engineering/babel.html" class="nav-link sidebar-item" aria-label="Babel"><!--[--><!--]--> Babel <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/front-end-engineering/jenkins.html" class="nav-link sidebar-item" aria-label="Jenkins配置"><!--[--><!--]--> Jenkins配置 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/front-end-engineering/rollup.html" class="nav-link sidebar-item" aria-label="RollUp"><!--[--><!--]--> RollUp <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/front-end-engineering/lerna.html" class="nav-link sidebar-item" aria-label="基于 Lerna 管理 monorepo 项目"><!--[--><!--]--> 基于 Lerna 管理 monorepo 项目 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/front-end-engineering/vue2%E6%94%B9%E9%80%A0%E4%B8%BAvite%E6%9E%84%E5%BB%BA.html" class="nav-link sidebar-item" aria-label="vue2项目进行vite改造"><!--[--><!--]--> vue2项目进行vite改造 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/front-end-engineering/vconsole.html" class="nav-link sidebar-item" aria-label="vconsole不同环境打包引入"><!--[--><!--]--> vconsole不同环境打包引入 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--[--><a href="/fe-study/programming-design/" class="nav-link sidebar-heading sidebar-item" aria-label="程序设计和场景分析"><!--[--><!--]--> 程序设计和场景分析 <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/fe-study/programming-design/how-to-make-a-game.html" class="nav-link sidebar-item" aria-label="如何制作一个游戏？"><!--[--><!--]--> 如何制作一个游戏？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/programming-design/how-to-design-a-component-lib.html" class="nav-link sidebar-item" aria-label="如何设计一个组件库"><!--[--><!--]--> 如何设计一个组件库 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/programming-design/how-to-design-a-web-monitor-system.html" class="nav-link sidebar-item" aria-label="如何设计一个前端监控系统"><!--[--><!--]--> 如何设计一个前端监控系统 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--[--><a href="/fe-study/other/" class="nav-link sidebar-heading sidebar-item" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/fe-study/other/indexedDB.html" class="nav-link sidebar-item" aria-label="indexedDB 浏览器数据库"><!--[--><!--]--> indexedDB 浏览器数据库 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/other/vuePress.html" class="nav-link sidebar-item" aria-label="vuePress 使用"><!--[--><!--]--> vuePress 使用 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/other/nginx.html" class="nav-link sidebar-item" aria-label="Nginx概念与使用"><!--[--><!--]--> Nginx概念与使用 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/other/sentry.html" class="nav-link sidebar-item" aria-label="Sentry"><!--[--><!--]--> Sentry <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--[--><a href="/fe-study/awesome/" class="nav-link sidebar-heading sidebar-item" aria-label="收藏的文章"><!--[--><!--]--> 收藏的文章 <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/fe-study/awesome/React.html" class="nav-link sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/awesome/Typescript.html" class="nav-link sidebar-item" aria-label="Typescript"><!--[--><!--]--> Typescript <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/awesome/Taro.html" class="nav-link sidebar-item" aria-label="Taro"><!--[--><!--]--> Taro <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/awesome/concepts.html" class="nav-link sidebar-item" aria-label="前端新概念和趋势"><!--[--><!--]--> 前端新概念和趋势 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/awesome/tools.html" class="nav-link sidebar-item" aria-label="提效工具和网站"><!--[--><!--]--> 提效工具和网站 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/awesome/network.html" class="nav-link sidebar-item" aria-label="网络"><!--[--><!--]--> 网络 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/fe-study/awesome/other.html" class="nav-link sidebar-item" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="js基础知识题目" tabindex="-1"><a class="header-anchor" href="#js基础知识题目" aria-hidden="true">#</a> JS基础知识题目</h1><h2 id="_1-介绍一下js的数据类型有哪些-值是如何存储的" tabindex="-1"><a class="header-anchor" href="#_1-介绍一下js的数据类型有哪些-值是如何存储的" aria-hidden="true">#</a> 1. 介绍一下js的数据类型有哪些，值是如何存储的</h2><p>7种基本类型</p><pre><code>Undefined
Null
Boolean
String
Number
Symbol(ES6新增)
BigInt(ES10新增)
</code></pre><p>1种引用类型</p><pre><code>Object，包含 Function、Array、Date
</code></pre><p>基本类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><p>引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h3 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h3><p><a href="https://juejin.cn/post/6844903990904225805" target="_blank" rel="noopener noreferrer">「前端料包」可能是最透彻的JavaScript数据类型详解<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a><a href="https://juejin.cn/post/6844904200917221389" target="_blank" rel="noopener noreferrer">由浅入深，66条JavaScript面试知识点<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a></p><h2 id="_2-如何判断类型" tabindex="-1"><a class="header-anchor" href="#_2-如何判断类型" aria-hidden="true">#</a> 2. 如何判断类型？</h2><ul><li>undefined，typeof判断</li><li>null，typeof判断类型为 object，同时取反为 true，则证明是null；或者 <code>Object.prototype.toString.call(null)</code></li><li>number，typeof判断</li><li>string，typeof判断</li><li>boolean，typeof判断</li><li>bigInt，typeof判断</li><li>symbol，typeof判断</li><li>Object，<code>Object.prototype.toString.call(a)</code></li><li>Array，使用 Array.isArray 、instanceof 、<code>Object.prototype.toString.call([])</code></li><li>Function，typeof判断</li></ul><p>都可以使用 <code>Object.prototype.toString.call()</code> 去判断</p><h2 id="_3-js的数据类型的转换" tabindex="-1"><a class="header-anchor" href="#_3-js的数据类型的转换" aria-hidden="true">#</a> 3. js的数据类型的转换</h2><p>在 JS 中类型转换只有三种情况，分别是：</p><ol><li><p>转换为布尔值（调用Boolean()方法）</p></li><li><p>转换为数字（调用Number()、parseInt()和parseFloat()方法）</p></li><li><p>转换为字符串（调用.toString()或者String()方法）</p><p>null和underfined没有.toString方法</p></li></ol><h2 id="_4-、-和-运算符分别能做什么" tabindex="-1"><a class="header-anchor" href="#_4-、-和-运算符分别能做什么" aria-hidden="true">#</a> 4. &amp;&amp; 、 ||和!! 运算符分别能做什么</h2><ul><li>&amp;&amp; 叫逻辑与，在其操作数中找到第一个虚值表达式并返回它，如果没有找到任何虚值表达式，则返回最后一个真值表达式。它采用短路来防止不必要的工作。</li><li>|| 叫逻辑或，在其操作数中找到第一个真值表达式并返回它。这也使用了短路来防止不必要的工作。在支持 ES6 默认函数参数之前，它用于初始化函数中的默认参数值。</li><li>!! 运算符可以将右侧的值强制转换为布尔值，这也是将值转换为布尔值的一种简单方法。</li></ul><h2 id="_5-js中数据类型的判断-typeof-instanceof-constructor-object-prototype-tostring-call" tabindex="-1"><a class="header-anchor" href="#_5-js中数据类型的判断-typeof-instanceof-constructor-object-prototype-tostring-call" aria-hidden="true">#</a> 5. JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call())</h2><h2 id="_6-介绍-js-有哪些内置对象" tabindex="-1"><a class="header-anchor" href="#_6-介绍-js-有哪些内置对象" aria-hidden="true">#</a> 6. 介绍 js 有哪些内置对象？</h2><h2 id="_7-undefined-与-undeclared-的区别" tabindex="-1"><a class="header-anchor" href="#_7-undefined-与-undeclared-的区别" aria-hidden="true">#</a> 7. undefined 与 undeclared 的区别？</h2><p><code>undefined</code> 属于已定义但是未赋值的变量；可以使用 <code>typeof</code> 去判断</p><p>undeclared 其实就是 <code>xxx is not defined</code> ，属于在作用域中没有声明过的变量；也可以使用 <code>typeof</code> 去判断</p><h2 id="_8-null-和-undefined-的区别" tabindex="-1"><a class="header-anchor" href="#_8-null-和-undefined-的区别" aria-hidden="true">#</a> 8. null 和 undefined 的区别？</h2><p>两者都是基本数据类型；分别只有一个值，<code>null</code> 和 <code>undefined</code><code>undefined</code> 代表的是变量已声明，但未赋值 <code>null</code> 代表的是空对象</p><p>typeof 判断 <code>null</code> 会返回 <code>object</code>，这是历史悠久的bug</p><h2 id="_9-和-的valueof和tostring的结果是什么" tabindex="-1"><a class="header-anchor" href="#_9-和-的valueof和tostring的结果是什么" aria-hidden="true">#</a> 9. {}和[]的valueOf和toString的结果是什么？</h2><pre><code>{} 的 valueOf 结果为 {} ，toString 的结果为 &quot;[object Object]&quot;

[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;
</code></pre><h2 id="_10-javascript-的作用域和作用域链" tabindex="-1"><a class="header-anchor" href="#_10-javascript-的作用域和作用域链" aria-hidden="true">#</a> 10. Javascript 的作用域和作用域链</h2><p>作用域： 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。 作用域链： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。</p><h2 id="_11-javascript-创建对象的几种方式" tabindex="-1"><a class="header-anchor" href="#_11-javascript-创建对象的几种方式" aria-hidden="true">#</a> 11. javascript 创建对象的几种方式？</h2><p>红宝书中有详细描述</p><p>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js 和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象 创建方式，我了解到的方式有这么几种：</p><pre><code>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。

（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。

（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。

（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。

（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。

（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。
</code></pre><h2 id="_12-javascript-继承的几种实现方式" tabindex="-1"><a class="header-anchor" href="#_12-javascript-继承的几种实现方式" aria-hidden="true">#</a> 12. JavaScript 继承的几种实现方式？</h2><pre><code>构造函数继承
原型继承
原型链继承
组合继承
寄生继承
寄生组合继承
ES6的class继承
</code></pre><h2 id="_13-寄生式组合继承的实现" tabindex="-1"><a class="header-anchor" href="#_13-寄生式组合继承的实现" aria-hidden="true">#</a> 13. 寄生式组合继承的实现？</h2><pre><code>```js
function Parent(name) {
    this.name = name
}

Parent.prototype.say = function() {
    console.log(this.name)
}

function Son(name, age = 12) {
    Parent.call(this, name);
    this.age = age
}

Son.prototype = Object.create(Parent.prototype)
Son.prototype.constructor = Son

Son.prototype.getName = function() {
    console.log(this.name + &#39;from Son prototype&#39;)
}

var son = new Son(&#39;xiaoming&#39;, 11)
```
</code></pre><h2 id="_14-谈谈你对this、call、apply和bind的理解" tabindex="-1"><a class="header-anchor" href="#_14-谈谈你对this、call、apply和bind的理解" aria-hidden="true">#</a> 14. 谈谈你对this、call、apply和bind的理解</h2><pre><code>在浏览器里，在全局范围内this 指向window对象；
在函数中，this永远指向最后调用他的那个对象；
构造函数中，this指向new出来的那个新的对象；
call、apply、bind中的this被强绑定在指定的那个对象上；
箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；
apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。
</code></pre><h2 id="_15-javascript-原型-原型链-有什么特点" tabindex="-1"><a class="header-anchor" href="#_15-javascript-原型-原型链-有什么特点" aria-hidden="true">#</a> 15. JavaScript 原型，原型链？ 有什么特点？</h2><p>每个函数都会创建一个 <code>prototype</code> 的属性，这个属性是一个对象。这个对象就是通过调用构造函数创建的对象的原型。 使用原型的好处是，在它上面定义的属性和方法，可以被所有对象实例共享</p><p>每个构造函数都有一个原型对象，原型有一个属性指向构造函数，而实例有一个内部指针指向原型。 如果原型式另一个类型的实例？那就意味着这个原型本身有一个内部指针指向另一个原型，相应的另一个原型也有一个指针指向另一个原型。这样就在实例和原型之间构造了一条原型链</p><pre><code>```js
function Parent(){}
let instance = new Parent();

console.log(instance.__proto__ === Parent.prototype)
console.log(instance.__proto__.__proto__ === Parent.prototype.__proto__)
console.log(instance.__proto__.__proto__ === Object.prototype)
console.log(instance.__proto__.__proto__.__proto__ === null)
```
</code></pre><h2 id="_16-js-获取原型的方法" tabindex="-1"><a class="header-anchor" href="#_16-js-获取原型的方法" aria-hidden="true">#</a> 16. js 获取原型的方法？</h2><pre><code>```js
function Parent(){}

let instance = new Parent();

console.log(instance.__proto__)
console.log(Object.getPrototypeOf(instance))
console.log(Parent.prototype)
```
</code></pre><h2 id="_17-什么是闭包-为什么要用它" tabindex="-1"><a class="header-anchor" href="#_17-什么是闭包-为什么要用它" aria-hidden="true">#</a> 17. 什么是闭包，为什么要用它？</h2><p>闭包就是有权访问另外一个函数的变量</p><p>闭包的用途</p><pre><code>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。
</code></pre><p>其实闭包的本质就是作用域链的一个特殊的应用</p><h2 id="_18-什么是-dom-和-bom" tabindex="-1"><a class="header-anchor" href="#_18-什么是-dom-和-bom" aria-hidden="true">#</a> 18. 什么是 DOM 和 BOM？</h2><p>// TODO</p><h2 id="_19-三种事件模型是什么" tabindex="-1"><a class="header-anchor" href="#_19-三种事件模型是什么" aria-hidden="true">#</a> 19. 三种事件模型是什么？</h2><p>// TODO</p><h2 id="_20-事件委托是什么" tabindex="-1"><a class="header-anchor" href="#_20-事件委托是什么" aria-hidden="true">#</a> 20. 事件委托是什么？</h2><p>事件委托的本质是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到 目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</p><p>使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</p><h2 id="_21-什么是事件传播" tabindex="-1"><a class="header-anchor" href="#_21-什么是事件传播" aria-hidden="true">#</a> 21. 什么是事件传播?</h2><p>事件传播有三个阶段</p><pre><code>捕获
目标
冒泡
</code></pre><h2 id="_22-什么是事件捕获-什么是事件冒泡" tabindex="-1"><a class="header-anchor" href="#_22-什么是事件捕获-什么是事件冒泡" aria-hidden="true">#</a> 22. 什么是事件捕获？什么是事件冒泡？</h2><p>addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。</p><p>例如click事件 事件捕获：从上到下 事件冒泡：从下到上</p><pre><code>window -&gt; document -&gt; html -&gt; body -&gt; div
window &lt;- document &lt;- html &lt;- body &lt;- div
</code></pre><h2 id="_23-dom-操作——怎样添加、移除、移动、复制、创建和查找节点" tabindex="-1"><a class="header-anchor" href="#_23-dom-操作——怎样添加、移除、移动、复制、创建和查找节点" aria-hidden="true">#</a> 23. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h2><p>// TODO:</p><h2 id="_24-js数组和字符串有哪些原生方法-列举一下" tabindex="-1"><a class="header-anchor" href="#_24-js数组和字符串有哪些原生方法-列举一下" aria-hidden="true">#</a> 24. js数组和字符串有哪些原生方法,列举一下</h2><p>JS数组 push 尾部添加一个元素 pop 移除最后一个元素，并返回 shift 删除第一个元素，并返回 unshift 数组开头添加一个元素 splice 用于插入、删除或替换数组的元素 slice 从数组中返回选定的元素 concat 合并数组 join 数组合并为一个字符串，以指定的分隔符 toString 数组字符串 sort 排序（从小到大，ASCII码） indexOf 返回索引 forEach 循环遍历数组 map 循环遍历数组，返回新的数组</p><p>// TODO:</p><p>字符串</p><h2 id="_25-常用的正则表达式" tabindex="-1"><a class="header-anchor" href="#_25-常用的正则表达式" aria-hidden="true">#</a> 25. 常用的正则表达式</h2><p>// TODO:</p><h2 id="_26-ajax-是什么-如何创建一个-ajax" tabindex="-1"><a class="header-anchor" href="#_26-ajax-是什么-如何创建一个-ajax" aria-hidden="true">#</a> 26. Ajax 是什么? 如何创建一个 Ajax？</h2><p>异步通信的方法，由JS脚本向服务器发出请求，获取服务器响应后，局部更新网页内容</p><p>// TODO: // 手写实现</p><p>// promise封装</p><h2 id="_27-js-延迟加载的方式有哪些" tabindex="-1"><a class="header-anchor" href="#_27-js-延迟加载的方式有哪些" aria-hidden="true">#</a> 27. js 延迟加载的方式有哪些？</h2><p>// TODO:</p><h2 id="_28-谈谈你对模块化开发的理解" tabindex="-1"><a class="header-anchor" href="#_28-谈谈你对模块化开发的理解" aria-hidden="true">#</a> 28. 谈谈你对模块化开发的理解？</h2><p>模块是实现一个特定功能的一组方法</p><p>js最早只是实现一些简单的功能，后来随着程序越来越复杂，代码的模块化开发变得很重要 函数具有独立作用域的特点，最原始是使用函数作为模块，但是容易造成全局污染 后来使用对象写法，将函数作为对象的一个方法来实现，但是会暴露所有的模块成员，外部代码可以修改内部属性 后来用立即执行函数，通过利用闭包来实现模块的私有作用域的实现，不会对全局变量造成污染</p><h2 id="_29-js-的几种模块规范" tabindex="-1"><a class="header-anchor" href="#_29-js-的几种模块规范" aria-hidden="true">#</a> 29. js 的几种模块规范？</h2><p>// TODO: commonJS module.exports AMD require CMD seajs ES6</p><h2 id="_30-amd和cmd规范的区别" tabindex="-1"><a class="header-anchor" href="#_30-amd和cmd规范的区别" aria-hidden="true">#</a> 30. AMD和CMD规范的区别</h2><p>它们之间的主要区别有两个方面。</p><p>第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</p><p>第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p><h2 id="_31-es6-模块与-commonjs-模块、amd、cmd-的差异。" tabindex="-1"><a class="header-anchor" href="#_31-es6-模块与-commonjs-模块、amd、cmd-的差异。" aria-hidden="true">#</a> 31. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h2><p>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p><p>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><h2 id="_32-requirejs的核心原理是什么" tabindex="-1"><a class="header-anchor" href="#_32-requirejs的核心原理是什么" aria-hidden="true">#</a> 32. requireJS的核心原理是什么？</h2><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。 1，概念</p><p>requireJS是基于AMD模块加载规范，使用回调函数来解决模块加载的问题。</p><p>2，原理 （如何动态加载的？）</p><p>requireJS是使用创建script元素，通过指定script元素的src属性来实现加载模块的。</p><p>3，特点</p><ol><li>实现js文件的异步加载，避免网页失去响应</li><li>管理模块之间的依赖，便于代码的编写和维护</li></ol><p>4，requireJS为何不会多次加载同一个文件?怎么理解内部机制?</p><p>模块的定义是一个function，这个function实际是一个 factory（工厂模式），这个 factory 在需要使用的时候（require(&quot;xxxx&quot;) 的时候）才有可能会被调用。因为如果检查到已经调用过，已经生成了模块实例，就直接返回模块实例，而不再次调用工厂方法了。</p><h2 id="_33-谈谈js的运行机制" tabindex="-1"><a class="header-anchor" href="#_33-谈谈js的运行机制" aria-hidden="true">#</a> 33. 谈谈JS的运行机制</h2><ol><li>js单线程</li><li>js事件循环</li></ol><p>同步任务、异步任务</p><p>宏任务和微任务</p><pre><code>Macrotasks包括: script（整体代码）、setTimeout, setInterval, setImmediate, I/O, UI Rendering；

Microtasks包括: process.nextTick, Promise, Object.observe, MutationObserver。
</code></pre><p>Macrotasks、Microtasks执行机制：</p><p>1.主线程执行完后会先到micro-task队列中读取可执行任务</p><p>2.主线程执行micro-task任务</p><p>3.主线程到macro-task任务队列中读取可执行任务</p><p>4.主线程执行macro-task任务</p><p>5....转到Step 1</p><p>这里注意的是，UI Rendering是在micro-task之后执行，需要在UI渲染之前执行的逻辑，一般采用micro-task异步回调方式进行调用。</p><p>同样，micro-task队列不宜过长，给micro-task队列添加过多回调阻塞macro-task队列的任务执行是小事，重点是这有可能会阻塞UI Render，导致页面不能更新。浏览器也会基于性能方面的考虑，对micro-task中的任务个数进行限制。</p><p><a href="https://zhuanlan.zhihu.com/p/33058983" target="_blank" rel="noopener noreferrer">详解JavaScript中的Event Loop（事件循环）机制 <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a></p><h2 id="_34-arguments-的对象是什么" tabindex="-1"><a class="header-anchor" href="#_34-arguments-的对象是什么" aria-hidden="true">#</a> 34. arguments 的对象是什么？</h2><p>arguments对象是函数中传递的参数值的集合。它是一个类似数组的对象</p><p>注意:箭头函数中没有arguments对象。</p><h2 id="_35-为什么在调用这个函数时-代码中的b会变成一个全局变量" tabindex="-1"><a class="header-anchor" href="#_35-为什么在调用这个函数时-代码中的b会变成一个全局变量" aria-hidden="true">#</a> 35. 为什么在调用这个函数时，代码中的b会变成一个全局变量?</h2><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>首先，表达式b = 0求值，在本例中b没有声明。因此，JS引擎在这个函数外创建了一个全局变量b，之后表达式b = 0的返回值为0，并赋给新的局部变量a。</p><h2 id="_36-简单介绍一下-v8-引擎的垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#_36-简单介绍一下-v8-引擎的垃圾回收机制" aria-hidden="true">#</a> 36. 简单介绍一下 V8 引擎的垃圾回收机制</h2><p>// TODO:</p><h2 id="_37-哪些操作会造成内存泄漏" tabindex="-1"><a class="header-anchor" href="#_37-哪些操作会造成内存泄漏" aria-hidden="true">#</a> 37. 哪些操作会造成内存泄漏？</h2><p>1.意外的全局变量 2.被遗忘的计时器或回调函数 3.脱离 DOM 的引用 4.闭包</p><pre><code>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。
</code></pre><h2 id="_38-ecmascript-是什么" tabindex="-1"><a class="header-anchor" href="#_38-ecmascript-是什么" aria-hidden="true">#</a> 38. ECMAScript 是什么？</h2><p>暂时不需要了解</p><p>javaScript = ECMAScript + DOM + BOM（自认为是一种广义的JavaScript）</p><p>ECMAScript说什么JavaScript就得做什么！</p><h2 id="_39-es6的新特性" tabindex="-1"><a class="header-anchor" href="#_39-es6的新特性" aria-hidden="true">#</a> 39. ES6的新特性</h2><pre><code>块级作用域
let const
class
Promise
箭头函数
模板字符串
Symbol
代理proxy
Set Map WeakSet WeakMap
对象解构赋值
模块 import export
</code></pre><h2 id="_40-var-let-const的区别" tabindex="-1"><a class="header-anchor" href="#_40-var-let-const的区别" aria-hidden="true">#</a> 40. var let const的区别</h2><p>var 在全局作用域下声明的变量会挂在window下，let const不会</p><p>var 声明的变量，会变量提升</p><p>const声明的常量，不能被修改；声明的对象，引用地址不会被修改，但是对象的属性可以修改和添加删除</p><p>同一作用域下let和const不能声明同名变量，而var可以</p><p>暂时死区</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token comment">//在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span>
    <span class="token comment">// 而这时，还未到声明时候，所以控制台Error:a is not defined</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_41-什么是箭头函数" tabindex="-1"><a class="header-anchor" href="#_41-什么是箭头函数" aria-hidden="true">#</a> 41. 什么是箭头函数？</h2><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p><p>箭头函数没有自己的this值。它捕获词法作用域函数的this值</p><h2 id="_42-什么是类" tabindex="-1"><a class="header-anchor" href="#_42-什么是类" aria-hidden="true">#</a> 42. 什么是类？</h2><p>类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。</p><h2 id="_43-什么是模板字符串" tabindex="-1"><a class="header-anchor" href="#_43-什么是模板字符串" aria-hidden="true">#</a> 43. 什么是模板字符串？</h2><p>模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。</p><h2 id="_44-什么是对象解构" tabindex="-1"><a class="header-anchor" href="#_44-什么是对象解构" aria-hidden="true">#</a> 44. 什么是对象解构？</h2><p>对象析构是从对象或数组中获取或提取值的一种新的、更简洁的方法</p><h2 id="_45-什么是set对象-它是如何工作的" tabindex="-1"><a class="header-anchor" href="#_45-什么是set对象-它是如何工作的" aria-hidden="true">#</a> 45. 什么是Set对象，它是如何工作的？</h2><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用</p><p>WeakSet Map WeakMap</p><p>另外还有WeakSet， 与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet对该对象的引用。</p><p>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p><p>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</p><h2 id="_46-什么是proxy" tabindex="-1"><a class="header-anchor" href="#_46-什么是proxy" aria-hidden="true">#</a> 46. 什么是Proxy？</h2><p>Proxy 用于修改某些操作的默认行为。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><h2 id="_47-写一个通用的事件侦听器函数" tabindex="-1"><a class="header-anchor" href="#_47-写一个通用的事件侦听器函数" aria-hidden="true">#</a> 47. 写一个通用的事件侦听器函数</h2><h2 id="_48-什么是函数式编程-javascript的哪些特性使其成为函数式语言的候选语言" tabindex="-1"><a class="header-anchor" href="#_48-什么是函数式编程-javascript的哪些特性使其成为函数式语言的候选语言" aria-hidden="true">#</a> 48. 什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？</h2><p>函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。</p><p>函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。 函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。</p><h2 id="_49-什么是高阶函数" tabindex="-1"><a class="header-anchor" href="#_49-什么是高阶函数" aria-hidden="true">#</a> 49. 什么是高阶函数？</h2><p>高阶函数源自于函数式编程（不熟悉的朋友请看《javascript中的函数式编程》），是函数式编程的基本技术。 高阶函数只是将函数作为参数或返回值的函数。</p><p>那么，JS作为一门“一切皆为对象”的语言，是如何拥有函数式编程的能力呢？ 是因为在JS中函数是一等公民，即函数可以被赋值给变量，被变量引用，这便使得函数可以作为参数，在其他函数间相互传递：</p><p>函数式编程</p><pre><code>1. 纯函数
2. 柯里化
3. compose
</code></pre><h2 id="_50-为什么函数被称为一等公民" tabindex="-1"><a class="header-anchor" href="#_50-为什么函数被称为一等公民" aria-hidden="true">#</a> 50. 为什么函数被称为一等公民？</h2><p>是因为在JS中函数是一等公民，即函数可以被赋值给变量，被变量引用，这便使得函数可以作为参数，在其他函数间相互传递：</p><p>不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">9/12/2022, 5:33:14 AM</span></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: zhs25427199@gmail.com">vandvassily</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/fe-study/assets/app.9bc35547.js" defer></script>
  </body>
</html>
